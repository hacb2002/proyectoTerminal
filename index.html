<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <script src="main.js"></script>
    <script src="prueba.js"></script>
    <style>
        textarea {
            width: 500px;
            height: 200px;
        }

        svg {
            min-height: 1000px;
            aspect-ratio: 1 / 1;
            border: 1px solid black;
        }

        svg line {
            marker-end: url(#marker12);
        }

        .flecha_negra {
            stroke-width: 1px;
            stroke: black;
        }

        .flecha_regreso {
            stroke-width: 1px;
            stroke: gray;
            stroke-opacity: 0.8;
            stroke-dasharray: 4 2;
        }

        .marco{
            fill: white;
            stroke: black;
            stroke-width: 0.5;
        }

        .marco_regresado {
            fill: white;
            fill-opacity: 0.5;
            stroke: gray;
            stroke-opacity: 0.8;
            stroke-width: 0.5;
        }


        .textoMarco{
            font-size: 4px;
        }

        .textoRegreso {
            font-size: 4px;
            font-weight: bold;
        }
    </style>
</head>
<body onload="inicializa()">
    Código: <textarea id="codigo">
int fibonacci(int n) {
    if (n <= 1){
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
    </textarea><br>
    Invocación: <input type="text" id="invocacion" value="fibonacci 4"><br>
    Salida: <textarea id="salida" readonly></textarea><br>
    <button type="button" id="boton">Procesar</button>
    <button type="button" id="anterior">Anterior</button>
    <button type="button" id="siguiente">Siguiente</button>
    <button type="button" id="pila">Pila</button>
    <button type="button" id="arbol">Árbol</button>

      <svg id="svg" viewbox="0 0 500 500"> 
         <marker id="triangle" viewBox="0 0 10 10" refX="0" refY="5" markerUnits="strokeWidth" markerWidth="7" markerHeight="5" orient="auto">
            <path d="M 0,0 L 10,5 L 0,10 Z" />
         </marker>
       <marker
       style="overflow:visible"
       id="ArrowWideHeavy"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide, heavy arrow"
       markerWidth="1.5"
       markerHeight="1.5"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:context-stroke;fill-rule:evenodd;stroke:none"
         d="m 1,0 -3,3 h -2 l 3,-3 -3,-3 h 2 z"
         id="path5" />
      </marker>
      <marker
       markerWidth="4"
       markerHeight="4"
       refX="42.740033"
       refY="38.740066"
       orient="auto"
       id="marker12"
       viewBox="0 0 85.4800668 77.48013296"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:context-stroke;fill-rule:evenodd;stroke:none"
         d="M 0.94487997,76.535342 C 27.401573,57.637704 58.07874,46.299122 84.535436,38.740066 58.07874,31.181011 27.401573,19.842429 0.94487997,0.94479089 0.94487997,16.062901 24.062991,34.960539 27.842519,38.740066 24.062991,42.519594 0.94487997,61.417232 0.94487997,76.535342 Z"
         id="path11-5-2-7"
         sodipodi:nodetypes="ccccc" />
      </marker>
      <g id="capaDibujo"></g>
      </svg><br> 

    <script>
        let funciones = [];
        let instrucciones = [];
        let instruccionesArbol = [];
        let actual = 0;
        let maxVariables = 0;
        let maxAnchoVariables = 0;
        let maxAnchoTotal = 0;
        let maxArgumentos = 0;
        let maxAnchoNodo = 0;
        let maxAnchoRetorno = 0;
        let maxPila = 0;
        let svg = document.getElementById("svg");
        let ms = 1000;
        let altura = 25;
        let gap = 15;
        let ejecucionId = 0;
        let xMax = 0;
        let yMax = 0;
        
        async function limpiarSVG(){
            ejecucionId++;
            const capaDibujo = document.getElementById("capaDibujo");
            while (capaDibujo.firstChild) {
                capaDibujo.removeChild(capaDibujo.firstChild);
            }
        }

        function dibuja_marco(x, y, w = maxAnchoTotal, h = altura, clase = "marco") {
            let obj = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            obj.setAttribute("class", clase);
            obj.setAttribute("x", x);
            obj.setAttribute("y", y);
            obj.setAttribute("width", w);
            obj.setAttribute("height", h);
            return capaDibujo.appendChild(obj);
        }
        
        function dibuja_texto(x, y, texto, clase = "textoMarco") {
            let obj = document.createElementNS("http://www.w3.org/2000/svg", "text");
            obj.setAttribute("class", clase);
            obj.setAttribute("x", x);
            obj.setAttribute("y", y);
            obj.textContent = texto;
            return capaDibujo.appendChild(obj);
        }

        function medirTexto(texto, clase = "textoMarco") {
            const temp = document.createElementNS("http://www.w3.org/2000/svg", "text");
            temp.setAttribute("x", -9999);
            temp.setAttribute("y", -9999);
            if (clase) temp.setAttribute("class", clase);
            temp.textContent = texto;
            capaDibujo.appendChild(temp);
            const bbox = temp.getBBox();
            capaDibujo.appendChild(temp);
            return [bbox.height, bbox.width];
        }
        
        function dibuja_flecha(obj1, obj2, clase = "flecha_negra") {
            if(obj1 === null || obj2 === null){
                return null;
            }
            let [x1, y1] = coordenadas_elemento(obj1);
            x1 += obj1.getAttribute("width")/2;
            y1 += obj1.getAttribute("height")/1;
            let [x2, y2] = coordenadas_elemento(obj2);
            x2 += obj2.getAttribute("width")/2;
            y2-=2;
            let obj = document.createElementNS("http://www.w3.org/2000/svg", "line");
            obj.setAttribute("class", clase);
            obj.setAttribute("x1", x1);
            obj.setAttribute("y1", y1);
            obj.setAttribute("x2", x2);
            obj.setAttribute("y2", y2);
            return capaDibujo.appendChild(obj);
        }
        
        function dibuja_flecha_inversa(obj1, obj2, clase = "flecha_gris") {
            if(obj1 === null || obj2 === null){
                return null;
            }
            let [x1, y1] = coordenadas_elemento(obj1);
            x1 += obj1.getAttribute("width")/2;
            y1 -= 1;
            let [x2, y2] = coordenadas_elemento(obj2);
            x2 += obj2.getAttribute("width")/2;
            y2 += obj2.getAttribute("height")/1+2;
            let obj = document.createElementNS("http://www.w3.org/2000/svg", "line");
            obj.setAttribute("class", clase);
            obj.setAttribute("x1", x1);
            obj.setAttribute("y1", y1);
            obj.setAttribute("x2", x2);
            obj.setAttribute("y2", y2);
            return capaDibujo.appendChild(obj);
        }

        function elimina_elemento(obj) {
            obj?.remove();
        }

        class NodoFuncion {
            contenido;
            variables;
            fila;
            columna;
            hijos;
            marco;
            texto;
            flecha;
            constructor(variables) {
                this.hijos = [];
                this.variables = variables;
                this.fila = null;
                this.columna = null;
            }
        }


        class DibujoFuncion{
            nombreFuncion;
            flecha;
            constructor(marco){
                this.marco = marco;
                this.variables = new Map();
            }
            agregarVariable(id, nombre, valor, marco){
                this.variables.set(id, {nombre, valor, marco});
            }
            agregarNombreFuncion(nombreFuncion){
                this.nombreFuncion = nombreFuncion;
            }
            eliminarVariable(id){
                let variable = this.variables.get(id);
                elimina_elemento(variable.nombre);
                elimina_elemento(variable.valor);
                elimina_elemento(variable.marco);
                this.variables.delete(id);
            }
            obtenerCoordenadasMarco(){
                return coordenadas_elemento(this.marco);
            }
            destruirFuncion(){
                elimina_elemento(this.marco);
                elimina_elemento(this.nombreFuncion);
                for (const [clave, obj] of this.variables) {
                    elimina_elemento(obj.nombre);
                    elimina_elemento(obj.valor);
                    elimina_elemento(obj.marco);
                }
                if(this.flecha !== null) elimina_elemento(this.flecha);
            }
            obtenerCoordenadasUltimaVariable() {
                const vars = Array.from(this.variables.values());
                if (vars.length === 0) {
                    return null; 
                }
                const ultimaVar = vars[vars.length - 1];
                return coordenadas_elemento(ultimaVar.marco);
            }
            obtenerMarco(){
                return this.marco;
            }
        }

        async function dibujarPila() {
            limpiarSVG();
            let y = (altura+gap)*maxPila;
            document.getElementById("svg").setAttribute("viewBox", `0 0 ${maxAnchoTotal} ${y}`);
            let idr = ejecucionId;
            let funciones = [];
            for (let ins of instrucciones) {
                if (ins.startsWith("LLAMA")) {
                    let funcion = obtenerLlamada(ins);
                    let sig = [20, 10];
                    let marco_ant = null;
                    if(funciones.length > 0){
                        sig = funciones.at(-1).obtenerCoordenadasMarco();
                        sig[1] += altura+gap;
                        marco_ant = funciones.at(-1).obtenerMarco();
                    }
                    let marco_funcion = new DibujoFuncion(dibuja_marco(sig[0], sig[1]));
                    let nombreFuncion = dibuja_texto(sig[0]+1, sig[1]+5, funcion.nombreFuncion);
                    marco_funcion.agregarNombreFuncion(nombreFuncion);
                    let var_x = sig[0]+2;
                    let var_y = sig[1]+10;
                    for(let variable of funcion.variables){
                        let identificador = variable.id_variable;
                        let marcoVariable = dibuja_marco(var_x, var_y, maxAnchoVariables, 5);
                        let valorVariable = dibuja_texto(var_x+1, var_y+4, variable.valor);
                        let nombreVariable = dibuja_texto(var_x, var_y+5+5, variable.nombre);
                        marco_funcion.agregarVariable(identificador, nombreVariable, valorVariable, marcoVariable);
                        var_x += maxAnchoVariables+2;
                    }
                    marco_funcion.flecha = dibuja_flecha(marco_ant, marco_funcion.marco, "flecha_negra");
                    funciones.push(marco_funcion);
                }
                else if(ins.startsWith("DECLARA")){
                    let declaracion = obtenerDeclaracion(ins);
                    let coordenadas = funciones[funciones.length-1].obtenerCoordenadasUltimaVariable();
                    let xsig = coordenadas[0]+maxAnchoVariables+2;
                    let ysig = coordenadas[1];
                    let marco = dibuja_marco(xsig, ysig, maxAnchoVariables, 5);
                    let valorVariable = dibuja_texto(xsig+1, ysig+4, declaracion.valor);
                    let nombreVariable = dibuja_texto(xsig, ysig+5+5, declaracion.nombre);
                    funciones[funciones.length-1].agregarVariable(declaracion.id_variable,nombreVariable,valorVariable,marco);
                }
                else if(ins.startsWith("DESTRUYE")){
                    let destructor = obtenerDestructor(ins);
                    funciones[funciones.length-1].eliminarVariable(destructor);
                }
                else if(ins.startsWith("REGRESA")){
                    let retorno = obtenerRetorno(ins);
                    let coordenadas = funciones.at(-1).obtenerCoordenadasMarco();
                    funciones[funciones.length-1].destruirFuncion();
                    const texto = "REGRESA "+retorno;
                    const x = coordenadas[0];
                    const y = coordenadas[1]+altura/2;
                    let regresa = dibuja_texto(x, y, texto);
                    await retardo(ms, idr);
                    elimina_elemento(regresa);
                    funciones.pop();
                }else if(ins.startsWith("ERROR")){
                    alert(ins);
                }
                await retardo(ms, idr);
            }
        }

        function retardo(ms, id) {
            return new Promise(resolve => {
                setTimeout(() => {
                    if (id === ejecucionId) resolve();
                }, ms);
            });
        }

        async function calcular_marcos(){
            limpiarSVG();
            maxVariables = 0;
            maxAnchoVariables = 0;
            maxAnchoTotal = 0;
            maxArgumentos = 0;
            maxAnchoNodo = 0;
            maxPila = 0;
            instruccionesArbol = [];
            let stack = [];
            funciones = [];
            for (let ins of instrucciones) {
                maxPila = Math.max(maxPila, stack.length);
                if (ins.startsWith("LLAMA")) {
                    let expresion = obtenerLlamada(ins);
                    instruccionesArbol.push(ins);
                    let actual = new NodoFuncion(expresion.variables.length);
                    maxVariables = Math.max(maxVariables, actual.variables);
                    maxArgumentos = Math.max(maxArgumentos, actual.variables);
                    funciones.push(actual);
                    if (stack.length > 0) {
                        stack.at(-1).hijos.push(actual);
                    }
                    stack.push(actual);
                    maxAnchoTotal = Math.max(medirTexto(expresion.nombreFuncion)[1] + 2, maxAnchoTotal);
                    let contenido = expresion.nombreFuncion+" (";
                    for(let j = 0; j<expresion.variables.length; ++j){
                        const nombre = medirTexto(expresion.variables[j].nombre)[1] + 2;
                        if(j<expresion.variables.length-1){
                            contenido += expresion.variables[j].valor + ", ";
                        }else{
                            contenido += expresion.variables[j].valor;
                        }
                        const valor = medirTexto(expresion.variables[j].valor)[1] + 2;
                        maxAnchoVariables = Math.max(maxAnchoVariables, valor, nombre);
                    }
                    contenido += ") ";
                    actual.contenido = contenido;
                    maxAnchoNodo = Math.max(maxAnchoNodo, medirTexto(contenido)[1]+2);
                    maxAnchoTotal = Math.max(maxAnchoTotal, maxVariables * (4 + maxAnchoVariables));
                }
                else if (ins.startsWith("DECLARA")) {
                    let variable = obtenerDeclaracion(ins);
                    const nombre = medirTexto(variable.nombre)[1] + 2;
                    const valor = medirTexto(variable.valor)[1] + 2;
                    maxAnchoVariables = Math.max(maxAnchoVariables, valor, nombre);
                    stack.at(-1).variables += 1;
                    maxVariables = Math.max(stack.at(-1).variables, maxVariables);
                    maxAnchoTotal = Math.max(maxVariables * (4 + maxAnchoVariables), maxAnchoTotal);
                }
                else if (ins.startsWith("DESTRUYE")) {
                    stack.at(-1).variables -= 1;
                }
                else if (ins.startsWith("REGRESA")) {
                    maxAnchoRetorno = Math.max(maxAnchoRetorno, medirTexto(obtenerRetorno(ins))[1]);
                    instruccionesArbol.push(ins);
                    stack.pop();
                }else{
                    instruccionesArbol.push(ins);
                }
            }
        }


        function obtenerLlamada(ins){
            const matchFuncion = ins.match(/LLAMA\s+[-\d]+:[-\d]+\s+(\w+)/);
            const nombreFuncion = matchFuncion[1];
            const regexVariables = /(\w+)#(\d+)\s*=\s*([+-]?\d+)/g;
            let match, variables = [];
            while ((match = regexVariables.exec(ins)) !== null) {
                const nombre = match[1];
                const id_variable = match[2];
                const valor = match[3];
                variables.push({id_variable, nombre, valor});
            }
            return {nombreFuncion, variables};
        }

        function obtenerDeclaracion(ins) {
            const regex = /^DECLARA\s+\d+:\d+\s+([A-Za-z_]\w*)#(\d+)=([+-]?\d+)$/;
            const match = regex.exec(ins);
            if (!match) {
                throw new Error(`Formato de declaración inválido: "${ins}"`);
            }
            const [, nombre, id_variable, valor] = match;
            return { id_variable, nombre, valor };
        }

        function obtenerDestructor(ins) {
            const regex = /^DESTRUYE\s+\d+:\d+\s+([A-Za-z_]\w*)#(\d+)$/;
            const match = regex.exec(ins);
            if (!match) {
                throw new Error(`Formato de destructor inválido: "${ins}"`);
            }
            const [, nombre, id_variable] = match;
            return id_variable;
        }


        function obtenerRetorno(ins){
            const matchFuncion = ins.match(/REGRESA\s+\d+:\d+\s+([+-]?\d+)/);
            return matchFuncion[1];
        }

        function calcularCoordenadasArbol(nodo, fila, columnaRef, ancho, gap) {
            let aumentoFila = 50+gap;
            let aumentoColumna = ancho+1;
            let numHijos = nodo.hijos.length;
            let particion = Math.floor(numHijos / 2) + (numHijos % 2);
            for (let i = 0; i < particion; ++i) {
                columnaRef = calcularCoordenadasArbol(nodo.hijos[i], fila + aumentoFila, columnaRef, ancho, gap);
            }
            if (numHijos % 2 === 0) {
                nodo.fila = fila;
                nodo.columna = columnaRef;
                columnaRef += aumentoColumna/2;
            } else {
                nodo.fila = fila;
                nodo.columna = nodo.hijos[particion - 1].columna;
            }
            xMax = Math.max(xMax, nodo.columna+aumentoColumna);
            yMax = Math.max(yMax, nodo.fila+6);
            for (let i = particion; i < numHijos; ++i) {
                columnaRef = calcularCoordenadasArbol(nodo.hijos[i], fila + aumentoFila, columnaRef, ancho, gap);
            }
            return columnaRef;

        }

        async function dibujarArbol() {
            xMax = 0;
            yMax = 0;
            calcularCoordenadasArbol(funciones[0], 5, 5, Math.max(maxAnchoNodo, maxAnchoRetorno), 5);
            console.log("x: "+xMax+"; y: "+yMax);
            document.getElementById("svg").setAttribute("viewBox", `0 0 ${xMax} ${yMax}`);
            limpiarSVG();
            let idr = ejecucionId;
            let i = 0;
            let stack = [];
            for (let ins of instruccionesArbol) {
                if (ins.startsWith("LLAMA")) {
                    let f = funciones[i++];
                    f.marco = dibuja_marco(f.columna, f.fila, maxAnchoNodo, 5);
                    f.texto = dibuja_texto(f.columna + 1, f.fila + 4, f.contenido);
                    if (stack.length > 0) {
                        f.flecha = dibuja_flecha(stack.at(-1).marco, f.marco);
                    }
                    stack.push(f);
                } else if(ins.startsWith("REGRESA")) {
                    let valor = obtenerRetorno(ins);
                    let f = stack.at(-1);
                    f.marco.setAttribute("class", "marco_regresado");
                    f.texto.setAttribute("fill", "gray");
                    stack.pop();
                    if(stack.length === 0){
                        dibuja_texto(funciones[0].columna, funciones[0].fila-2, valor, "textoRegreso");
                    }else{
                        f.flecha.setAttribute("class", "flecha_regreso");
                        let [x1, y1] = coordenadas_elemento(f.marco);
                        dibuja_texto(x1, y1-5, valor, "textoRegreso");
                    }
                }else{
                    alert(ins);
                }
                await retardo(ms, idr);
            }
        }
        
        async function inicializa() {
            let wasm = await cargador_wasm();
            let traduce = wasm.cwrap("traduce", "string", ["string", "string"]);
            document.getElementById("boton").onclick = async function() {
                const codigo = document.getElementById("codigo").value;
                const invocacion = document.getElementById("invocacion").value;
                const textoSalida = traduce(codigo, invocacion);
                document.getElementById("salida").value = textoSalida;
                instrucciones = textoSalida.trim().split("\n");
                actual = 0;
                await calcular_marcos();
            };
            document.getElementById("pila").onclick = dibujarPila;
            document.getElementById("arbol").onclick = dibujarArbol;
        }

    </script>
</body>
</html>